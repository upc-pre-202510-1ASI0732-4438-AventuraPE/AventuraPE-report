<div align="center">
    <h3>Universidad Peruana de Ciencias Aplicadas</h3>
    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png"></img><br>
    <strong>Ingeniería de Software - 7mo Ciclo</strong><br>
    <strong>Diseño de experimentos de Ingeniería de Software</strong><br>
    <strong>1ASI0732-4438</strong><br>
    <strong>Profesor: Julio Manuel Noriega Melendez</strong><br>
    <br><strong>Report</strong><br>
    <br><strong>AventuraPE</strong><br>
    <!--<strong>name startup</strong>-->
</div>

<h3> Team Members: </h3>

<div align="center">

| Member                              |    Code    |
| :---------------------------------- | :--------: |
| Jose Eduardo Gutierrez Garcia       | u202221518 |
| Cama Salvatierra, Jimena Tamara     | u202210778 |
| Castillo Castillo, Jair Alexander   | u202211390 |
| Estefano Oscar Jaque Peña           | u202225466 |
| Quezada Portalatino, Barbara Susana | u202211800 |

</div>

<h3 align="center">Abril, 2025</h3>

<br><br>

<div align="justify">

# Registro de Versiones del Informe

El objetivo de esta sección es resumir las modificaciones relevantes que se realizan al informe durante el ciclo de vida del proyecto. Esta sección inicia en una página nueva e incluye un cuadro con la siguiente estructura:

<table>
  <thead>
    <tr>
      <th>Versión</th>
      <th>Fecha</th>
      <th>Autor</th>
      <th>Descripción de modificación</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.1</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
    </tr>
    
  </tbody>
</table>

# Contenido

## [Capítulo I: Introducción](#capítulo-i-introducción)
- [1.1. Startup Profile](#11-startup-profile)
  - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
  - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
- [1.2. Solution Profile](#12-solution-profile)
  - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
  - [1.2.2. Lean UX Process](#122-lean-ux-process)
    - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
    - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
    - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
    - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
- [1.3. Segmentos objetivo](#13-segmentos-objetivo)

## [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)
- [2.1. Competidores](#21-competidores)
  - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
  - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
- [2.2. Entrevistas](#22-entrevistas)
  - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
  - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
  - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
- [2.3. Needfinding](#23-needfinding)
  - [2.3.1. User Personas](#231-user-personas)
  - [2.3.2. User Task Matrix](#232-user-task-matrix)
  - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
  - [2.3.4. Empathy Mapping](#234-empathy-mapping)
  - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
- [2.4. Ubiquitous Language](#24-ubiquitous-language)

## [Capítulo III: Requirements Specification](#capítulo-iii-requirements-specification)
- [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
- [3.2. User Stories](#32-user-stories)
- [3.3. Product Backlog](#33-product-backlog)
- [3.4. Impact Mapping](#34-impact-mapping)

## [Capítulo IV: Product Design](#capítulo-iv-product-design)
- [4.1. Style Guidelines](#41-style-guidelines)
  - [4.1.1. General Style Guidelines](#411-general-style-guidelines)
  - [4.1.2. Web Style Guidelines](#412-web-style-guidelines)
  - [4.1.3. Mobile Style Guidelines](#413-mobile-style-guidelines)
    - [4.1.3.1. iOS Mobile Style Guidelines](#4131-ios-mobile-style-guidelines)
    - [4.1.3.2. Android Mobile Style Guidelines](#4132-android-mobile-style-guidelines)
- [4.2. Information Architecture](#42-information-architecture)
  - [4.2.1. Organization Systems](#421-organization-systems)
  - [4.2.2. Labeling Systems](#422-labeling-systems)
  - [4.2.3. SEO Tags and Meta Tags](#423-seo-tags-and-meta-tags)
  - [4.2.4. Searching Systems](#424-searching-systems)
  - [4.2.5. Navigation Systems](#425-navigation-systems)
- [4.3. Landing Page UI Design](#43-landing-page-ui-design)
  - [4.3.1. Landing Page Wireframe](#431-landing-page-wireframe)
  - [4.3.2. Landing Page Mock-up](#432-landing-page-mock-up)
- [4.4. Mobile Applications UX/UI Design](#44-mobile-applications-uxui-design)
  - [4.4.1. Mobile Applications Wireframes](#441-mobile-applications-wireframes)
  - [4.4.2. Mobile Applications Wireflow Diagrams](#442-mobile-applications-wireflow-diagrams)
  - [4.4.3. Mobile Applications Mock-ups](#443-mobile-applications-mock-ups)
  - [4.4.4. Mobile Applications User Flow Diagrams](#444-mobile-applications-user-flow-diagrams)
- [4.5. Mobile Applications Prototyping](#45-mobile-applications-prototyping)
  - [4.5.1. Android Mobile Applications Prototyping](#451-android-mobile-applications-prototyping)
  - [4.5.2. iOS Mobile Applications Prototyping](#452-ios-mobile-applications-prototyping)
- [4.6. Web Applications UX/UI Design](#46-web-applications-uxui-design)
  - [4.6.1. Web Applications Wireframes](#461-web-applications-wireframes)
  - [4.6.2. Web Applications Wireflow Diagrams](#462-web-applications-wireflow-diagrams)
  - [4.6.3. Web Applications Mock-ups](#463-web-applications-mock-ups)
  - [4.6.4. Web Applications User Flow Diagrams](#464-web-applications-user-flow-diagrams)
- [4.7. Web Applications Prototyping](#47-web-applications-prototyping)
- [4.8. Domain-Driven Software Architecture](#48-domain-driven-software-architecture)
  - [4.8.1. Software Architecture Context Diagram](#481-software-architecture-context-diagram)
  - [4.8.2. Software Architecture Container Diagrams](#482-software-architecture-container-diagrams)
  - [4.8.3. Software Architecture Components Diagrams](#483-software-architecture-components-diagrams)
- [4.9. Software Object-Oriented Design](#49-software-object-oriented-design)
  - [4.9.1. Class Diagrams](#491-class-diagrams)
  - [4.9.2. Class Dictionary](#492-class-dictionary)
- [4.10. Database Design](#410-database-design)
  - [4.10.1. Relational/Non-Relational Database Diagram](#4101-relationalnon-relational-database-diagram)

## [Capítulo V: Product Implementation](#capítulo-v-product-implementation)
- [5.1. Software Configuration Management](#51-software-configuration-management)
  - [5.1.1. Software Development Environment Configuration](#511-software-development-environment-configuration)
  - [5.1.2. Source Code Management](#512-source-code-management)
  - [5.1.3. Source Code Style Guide & Conventions](#513-source-code-style-guide--conventions)
  - [5.1.4. Software Deployment Configuration](#514-software-deployment-configuration)
- [5.2. Product Implementation & Deployment](#52-product-implementation--deployment)
  - [5.2.1. Sprint Backlogs](#521-sprint-backlogs)
  - [5.2.2. Implemented Landing Page Evidence](#522-implemented-landing-page-evidence)
  - [5.2.3. Implemented Frontend-Web Application Evidence](#523-implemented-frontend-web-application-evidence)
  - [5.2.4. Implemented Native-Mobile Application Evidence](#524-implemented-native-mobile-application-evidence)
  - [5.2.5. Implemented RESTful API and/or Serverless Backend Evidence](#525-implemented-restful-api-andor-serverless-backend-evidence)
  - [5.2.6. RESTful API documentation](#526-restful-api-documentation)
  - [5.2.7. Team Collaboration Insights](#527-team-collaboration-insights)
- [5.3. Video About-the-Product](#53-video-about-the-product)

## [Part II: Verification, Validation & Pipeline](#part-ii-verification-validation--pipeline)

## [Capítulo VI: Product Verification & Validation](#capítulo-vi-product-verification--validation)
- [6.1. Testing Suites & Validation](#61-testing-suites--validation)
  - [6.1.1. Core Entities Unit Tests](#611-core-entities-unit-tests)
  - [6.1.2. Core Integration Tests](#612-core-integration-tests)
  - [6.1.3. Core Behavior-Driven Development](#613-core-behavior-driven-development)
  - [6.1.4. Core System Tests](#614-core-system-tests)
- [6.2. Static testing & Verification](#62-static-testing--verification)
  - [6.2.1. Static Code Analysis](#621-static-code-analysis)
    - [6.2.1.1. Coding standard & Code conventions](#6211-coding-standard--code-conventions)
    - [6.2.1.2. Code Quality & Code Security](#6212-code-quality--code-security)
  - [6.2.2. Reviews](#622-reviews)
- [6.3. Validation Interviews](#63-validation-interviews)
  - [6.3.1. Diseño de Entrevistas](#631-diseño-de-entrevistas)
  - [6.3.2. Registro de Entrevistas](#632-registro-de-entrevistas)
  - [6.3.3. Evaluaciones según heurísticas](#633-evaluaciones-según-heurísticas)
- [6.4. Auditoría de Experiencias de Usuario](#64-auditoría-de-experiencias-de-usuario)
  - [6.4.1. Auditoría realizada](#641-auditoría-realizada)
    - [6.4.1.1. Información del grupo auditado](#6411-información-del-grupo-auditado)
    - [6.4.1.2. Cronograma de auditoría realizada](#6412-cronograma-de-auditoría-realizada)
    - [6.4.1.3. Contenido de auditoría realizada](#6413-contenido-de-auditoría-realizada)
  - [6.4.2. Auditoría recibida](#642-auditoría-recibida)
    - [6.4.2.1. Información del grupo auditor](#6421-información-del-grupo-auditor)
    - [6.4.2.2. Cronograma de auditoría recibida](#6422-cronograma-de-auditoría-recibida)
    - [6.4.2.3. Contenido de auditoría recibida](#6423-contenido-de-auditoría-recibida)
    - [6.4.2.4. Resumen de modificaciones para subsanar hallazgos](#6424-resumen-de-modificaciones-para-subsanar-hallazgos)

## [Capítulo VII: DevOps Practices](#capítulo-vii-devops-practices)
- [7.1. Continuous Integration](#71-continuous-integration)
  - [7.1.1. Tools and Practices](#711-tools-and-practices)
  - [7.1.2. Build & Test Suite Pipeline Components](#712-build--test-suite-pipeline-components)
- [7.2. Continuous Delivery](#72-continuous-delivery)
  - [7.2.1. Tools and Practices](#721-tools-and-practices)
  - [7.2.2. Stages Deployment Pipeline Components](#722-stages-deployment-pipeline-components)
- [7.3. Continuous Deployment](#73-continuous-deployment)
  - [7.3.1. Tools and Practices](#731-tools-and-practices)
  - [7.3.2. Production Deployment Pipeline Components](#732-production-deployment-pipeline-components)
- [7.4. Continuous Monitoring](#74-continuous-monitoring)
  - [7.4.1. Tools and Practices](#741-tools-and-practices)
  - [7.4.2. Monitoring Pipeline Components](#742-monitoring-pipeline-components)
  - [7.4.3. Alerting Pipeline Components](#743-alerting-pipeline-components)
  - [7.4.4. Notification Pipeline Components](#744-notification-pipeline-components)

## [Part III: Experiment-Driven Lifecycle](#part-iii-experiment-driven-lifecycle)

## [Capítulo VIII: Experiment-Driven Development](#capítulo-viii-experiment-driven-development)
- [8.1. Experiment Planning](#81-experiment-planning)
  - [8.1.1. As-Is Summary](#811-as-is-summary)
  - [8.1.2. Raw Material](#812-raw-material-assumptions-knowledge-gaps-ideas-claims)
  - [8.1.3. Experiment-Ready Questions](#813-experiment-ready-questions)
  - [8.1.4. Question Backlog](#814-question-backlog)
  - [8.1.5. Experiment Cards](#815-experiment-cards)
- [8.2. Experiment Design](#82-experiment-design)
  - [8.2.1. Hypotheses](#821-hypotheses)
  - [8.2.2. Measures](#822-measures)
  - [8.2.3. Conditions](#823-conditions)
  - [8.2.4. Scale Calculations and Decisions](#824-scale-calculations-and-decisions)
  - [8.2.5. Methods Selection](#825-methods-selection)
  - [8.2.6. Data Analytics](#826-data-analytics-goals-kpis-and-metrics-selection)
  - [8.2.7. Web and Mobile Tracking Plan](#827-web-and-mobile-tracking-plan)
- [8.3. Experimentation](#83-experimentation)
  - [8.3.1. To-Be User Stories](#831-to-be-user-stories)
  - [8.3.2. To-Be Product Backlog](#832-to-be-product-backlog)
  - [8.3.3. Pipeline-supported Lifecycle](#833-pipeline-supported-experiment-driven-to-be-software-platform-lifecycle)
    - [8.3.3.1. To-Be Sprint Backlogs](#8331-to-be-sprint-backlogs)
    - [8.3.3.2. Landing Page Evidence](#8332-implemented-to-be-landing-page-evidence)
    - [8.3.3.3. Frontend-Web Application Evidence](#8333-implemented-to-be-frontend-web-application-evidence)
    - [8.3.3.4. Native-Mobile Application Evidence](#8334-implemented-to-be-native-mobile-application-evidence)
    - [8.3.3.5. RESTful API Evidence](#8335-implemented-to-be-restful-api-andor-serverless-backend-evidence)
    - [8.3.3.6. Team Collaboration Insights](#8336-team-collaboration-insights)
  - [8.3.4. To-Be Validation Interviews](#834-to-be-validation-interviews)
    - [8.3.4.1. Diseño de Entrevistas](#8341-diseño-de-entrevistas)
    - [8.3.4.2. Registro de Entrevistas](#8342-registro-de-entrevistas)
- [8.4. Experiment Aftermath & Analysis](#84-experiment-aftermath--analysis)
  - [8.4.1. Analysis and Interpretation of Results](#841-analysis-and-interpretation-of-results)
  - [8.4.2. Re-scored and Re-prioritized Question Backlog](#842-re-scored-and-re-prioritized-question-backlog)
- [8.5. Continuous Learning](#85-continuous-learning)
  - [8.5.1. Shareback Session Artifacts](#851-shareback-session-artifacts-learning-workflow)
- [8.6. To-Be Software Platform Pre-launch](#86-to-be-software-platform-pre-launch)
  - [8.6.1. About-the-Product Intro Video](#861-about-the-product-intro-video)

## [Conclusiones y recomendaciones](#conclusiones-y-recomendaciones)
## [Video About-the-Team](#video-about-the-team)
## [Bibliografía](#bibliografía)
## [Anexos](#anexos)


# Capítulo I: Introducción

## 1.1. Startup Profile

### 1.1.1. Descripción de la Startup  
### 1.1.2. Perfiles de integrantes del equipo  

## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática  
### 1.2.2. Lean UX Process  
#### 1.2.2.1. Lean UX Problem Statements  
#### 1.2.2.2. Lean UX Assumptions  
#### 1.2.2.3. Lean UX Hypothesis Statements  
#### 1.2.2.4. Lean UX Canvas  

## 1.3. Segmentos objetivo  

# Capítulo II: Requirements Elicitation & Analysis

## 2.1. Competidores  
### 2.1.1. Análisis competitivo  
### 2.1.2. Estrategias y tácticas frente a competidores  

## 2.2. Entrevistas  
### 2.2.1. Diseño de entrevistas  
### 2.2.2. Registro de entrevistas  
### 2.2.3. Análisis de entrevistas  

## 2.3. Needfinding  
### 2.3.1. User Personas  
### 2.3.2. User Task Matrix  
### 2.3.3. User Journey Mapping  
### 2.3.4. Empathy Mapping  
### 2.3.5. As-is Scenario Mapping  

## 2.4. Ubiquitous Language  

# Capítulo III: Requirements Specification

## 3.1. To-Be Scenario Mapping  
## 3.2. User Stories  
## 3.3. Product Backlog  
## 3.4. Impact Mapping  

# Capítulo IV: Product Design

## 4.1. Style Guidelines  
### 4.1.1. General Style Guidelines  
### 4.1.2. Web Style Guidelines  
### 4.1.3. Mobile Style Guidelines  
#### 4.1.3.1. iOS Mobile Style Guidelines  
#### 4.1.3.2. Android Mobile Style Guidelines  

## 4.2. Information Architecture  
### 4.2.1. Organization Systems  
### 4.2.2. Labeling Systems  
### 4.2.3. SEO Tags and Meta Tags  
### 4.2.4. Searching Systems  
### 4.2.5. Navigation Systems  

## 4.3. Landing Page UI Design  
### 4.3.1. Landing Page Wireframe  
### 4.3.2. Landing Page Mock-up  

## 4.4. Mobile Applications UX/UI Design  
### 4.4.1. Mobile Applications Wireframes  
### 4.4.2. Mobile Applications Wireflow Diagrams  
### 4.4.3. Mobile Applications Mock-ups  
### 4.4.4. Mobile Applications User Flow Diagrams  

## 4.5. Mobile Applications Prototyping  
### 4.5.1. Android Mobile Applications Prototyping  
### 4.5.2. iOS Mobile Applications Prototyping  

## 4.6. Web Applications UX/UI Design  
### 4.6.1. Web Applications Wireframes  
### 4.6.2. Web Applications Wireflow Diagrams  
### 4.6.3. Web Applications Mock-ups  
### 4.6.4. Web Applications User Flow Diagrams  

## 4.7. Web Applications Prototyping  

## 4.8. Domain-Driven Software Architecture  
### 4.8.1. Software Architecture Context Diagram  
### 4.8.2. Software Architecture Container Diagrams  
### 4.8.3. Software Architecture Components Diagrams  

## 4.9. Software Object-Oriented Design  
### 4.9.1. Class Diagrams  
### 4.9.2. Class Dictionary  

## 4.10. Database Design  
### 4.10.1. Relational/Non-Relational Database Diagram  

# Capítulo V: Product Implementation

## 5.1. Software Configuration Management  
### 5.1.1. Software Development Environment Configuration  

En esta sección se describen las herramientas y plataformas clave que utilizamos para orquestar, automatizar y ejecutar el despliegue de los distintos componentes de AventuraPe.

- **Git**  
  **Descripción:** Sistema de control de versiones distribuido que registra cada cambio en el código fuente.  
  **Uso:** Gestiona las versiones de nuestro código, permite crear ramas (`main`, `feat/deploy`, `develop`, etc.) y coordinar el flujo de trabajo entre desarrolladores.

- **GitHub**  
  **Descripción:** Plataforma de hosting de repositorios Git con funcionalidades de colaboración.  
  **Uso:** Aloja el código de backend, frontend y landing; gestiona issues, pull requests y sirve como origen para los despliegues.

- **GitHub Actions**  
  **Descripción:** Servicio de CI/CD nativo de GitHub que automatiza flujos de trabajo definidos mediante archivos YML.  
  **Uso:** Orquesta los build, test y deploy cada vez que se realiza un `push` o `pull request` en ramas designadas (`main` para landing, `feat/deploy` para back/front).

- **Firebase Hosting**  
  **Descripción:** Servicio de Google Firebase para servir contenido estático a través de una CDN global.  
  **Uso:** Hospeda la aplicación web desarrollada con Vue.js. Cada `push` a `feat/deploy` dispara el CLI de Firebase que realiza el build y publica los assets en producción con SSL automático.

- **Azure App Services**  
  **Descripción:** Plataforma PaaS de Microsoft Azure para ejecutar aplicaciones web y APIs en contenedores o directamente sobre el runtime.  
  **Uso:** Despliega el backend Spring Boot con Java 21 y PostgreSQL; Ya que `feat/deploy` compila, prueba y actualiza el servicio bajo HTTPS con escalado automático.

- **GitHub Pages**  
  **Descripción:** Servicio de hosting estático integrado en GitHub, ideal para landing pages.  
  **Uso:** Publica automáticamente los archivos de la carpeta `docs/` tras cada `push` a `main`, sirviendo la página de introducción y captación de usuarios.

- **Azure CLI**  
  **Descripción:** Interfaz de línea de comandos para gestionar recursos de Azure de forma programática.  
  **Uso:** Se integra con GitHub Actions para automatizar configuraciones del App Service, gestión de variables de entorno y despliegues sin intervención manual.

Con esta suite de herramientas desplegadas y coordinadas, AventuraPe mantiene un flujo de entrega continua robusto, minimiza el tiempo de inactividad y asegura que cada nueva versión llegue rápida y de forma fiable a todos los usuarios.

### 5.1.2. Source Code Management 

**Gestión del Código Fuente:**

En esta sección, se detalla cómo gestionamos y supervisamos el desarrollo del código para el proyecto de AventuraPe. Utilizamos GitHub como nuestra plataforma principal para la gestión del código fuente, complementada por Git como sistema de control de versiones. Además, seguimos el flujo de trabajo GitFlow para estructurar el desarrollo de manera eficiente.


**Ramas Principales:**
- **main:** Esta rama, a menudo llamada "master", contiene la versión más estable y final del proyecto, lista para ser desplegada en producción. Los cambios integrados en esta rama han pasado todas las pruebas y revisiones necesarias, y se consideran completamente preparados para su lanzamiento.

- **develop:** La rama develop es el punto central de integración para las nuevas funcionalidades y mejoras en desarrollo. Las características y correcciones se fusionan en esta rama, donde se realizan pruebas adicionales antes de su eventual integración en la rama main.

**Ramas Auxiliares:**

- **releases:** Las ramas de tipo releases se crean para preparar nuevas versiones del proyecto. En estas ramas se llevan a cabo las pruebas finales y se corrigen errores menores antes del lanzamiento oficial. Una vez que una versión ha sido validada, los cambios se integran en la rama develop para futuros desarrollos y luego se fusionan en la rama main para su despliegue.

**Uso de GitFlow:**

- **Feature Branches:** Se utilizan ramas de características para desarrollar nuevas funcionalidades. Estas ramas se crean a partir de la rama develop y, una vez que se completa el desarrollo y se aprueban las revisiones, se fusionan nuevamente en la rama develop.

- **Bugfix Branches:** Para solucionar errores que necesitan ser corregidos antes de la siguiente versión, se utilizan ramas de corrección de errores. Estas ramas se crean a partir de la rama develop o, en casos críticos, desde la rama main.

- **Hotfix Branches:** Se emplean para abordar errores críticos que requieren una solución urgente en producción. Estas ramas se crean a partir de la rama main, y una vez que el problema se resuelve, los cambios se fusionan tanto en la rama main como en la rama develop.

Este enfoque estructurado con GitFlow nos permite gestionar el desarrollo del código de manera eficiente, facilitando la integración de nuevas características, la corrección de errores y la preparación de versiones estables para producción.

**Commits Conventions:**

En AventuraPe, los commits se nombran de acuerdo con el avance y el contenido específico del trabajo realizado. No seguimos una convención rígida para los nombres de los commits; en su lugar, los desarrolladores utilizan descripciones claras y concisas para reflejar las modificaciones implementadas. Esto nos permite una mayor flexibilidad a la hora de registrar el progreso, asegurando que cada commit tenga un nombre que represente con precisión el trabajo efectuado.

### 5.1.3. Source Code Style Guide & Conventions  
Para mantener un código limpio, legible y fácil de mantener en equipo, se definieron guías de estilo específicas por tecnología, complementadas con linters automáticos y convenciones de nomenclatura. Estas prácticas se alinean con los principios de *Clean Code* y las recomendaciones de la comunidad técnica para cada stack.

#### **Frontend Web (Webstorm.js con TypeScript)**
- Las reglas aplicadas incluyeron:
  - **CamelCase** para variables y funciones (`handleClick`, `userList`).
  - **PascalCase** para nombres de componentes (`UserCard`, `ActivityCard`).
  - Uso estricto de `const` y `let` (evitando `var`).
  - Separación lógica de hooks y lógica de presentación en archivos distintos (`useActivityFetch.ts` vs `ActivityCard.tsx`).

#### **Backend (Spring Boot + Java)**
- Se adoptó la guía oficial de estilo de Java + convención de Spring:
  - Clases en **PascalCase** (`UserService`, `PublicationController`).
  - Variables y métodos en **camelCase** (`getPublications()`, `userId`).
  - Separación en paquetes según capa: `controller`, `service`, `repository`, `model`.
  - Uso de anotaciones estándar (`@RestController`, `@Autowired`, `@GetMapping`).
  - Código documentado con comentarios Javadoc (`/** */`) en servicios y endpoints principales.

#### **Android Mobile (Kotlin)**
- Se usó la convención oficial de Kotlin:
  - Nombres claros, concisos y expresivos.
  - Propiedades inmutables por defecto (`val`) y mutables solo cuando es estrictamente necesario (`var`).
  - Nombres de vistas en XML en snake_case (`btn_register`, `txt_user_email`).
  - En el código Kotlin, nombres de clases y funciones en PascalCase y camelCase respectivamente.
  - Arquitectura basada en **MVVM**, separando `ViewModel`, `Repository` y `UI`.

#### **General**
- Todos los equipos usaron **pre-commit hooks** con `Husky` (para frontend) y scripts personalizados en backend para evitar commits con errores de formato o linters.
- Se definieron **convenciones de nomenclatura de commits** usando el formato:
  - `feat:` para nuevas funcionalidades.
  - `fix:` para corrección de errores.
  - `docs:` para documentación.
  - `refactor:` para mejoras internas sin cambios funcionales.
  - `style:` para cambios de formato sin alterar la lógica.
Estas convenciones fueron aplicadas de forma continua mediante integración con GitHub Actions y revisión manual por parte del líder técnico antes de cada merge a `develop`.

### 5.1.4. Software Deployment Configuration

A continuación se detalla la configuración de el deployment de los tres componentes de AventuraPe, cada uno con su propio flujo de integración y entrega continua para asegurar despliegues automáticos, controlados y siempre actualizados.

#### 1. Landing Page

La página de entrada al producto, centrada en captar la atención de potenciales usuarios y presentar nuestra propuesta de valor:

- **Tecnologías**  
  - HTML5 semántico  
  - CSS3 con animaciones ligeras  
  - JavaScript vanilla para interactividad básica  

- **Despliegue**  
  - **Plataforma:** GitHub Pages  
  - **Branch:** `main`  
  - **Flujo:** mediante GitHub Actions, tras cada `push` a `main`, los archivos de la carpeta `docs/` se publican en el dominio configurado.  
  - **Beneficios:** publicación inmediata, versión de revisión histórica disponible, y control de versiones integrado con Git.  

Esta configuración asegura que la landing esté siempre al día, sirviendo como escaparate público y primer punto de contacto para nuevos usuarios e inversores.


#### 2. Frontend Web  
La Aplicacion web desarrollada en Vue.js que ofrece la experiencia de usuario rica e interactiva:

- **Tecnologías**  
  - Vue.js 3  

- **Despliegue**  
  - **Plataforma:** Firebase Hosting  
  - **Branch:** `feat/deploy`  
  - **Flujo:** un `push` a la rama `feat/deploy` ejecuta un script de build y luego publica automáticamente los archivos estáticos en Firebase  para entregas ultrarrápidas.  
  - **Beneficios:** SSL automático, previews de despliegue y rollback sencillo en caso de rollback.  

Con esto cualquier mejora o corrección en la interfaz llega casi instantáneamente a los usuarios finales, sin interrupciones.


#### 3. Backend RESTful  
Un servicio construido con Spring Boot que gestiona toda la lógica de negocio y persistencia de datos:

- **Tecnologías**  
  - Spring Boot 3.2
  - Java 21  
  - PostgreSQL

- **Despliegue**  
  - **Plataforma:** Azure App Services  
  - **Branch:** `feat/deploy`  
  - **Flujo:** cada vez que se hace un `push` a `feat/deploy`, un pipeline en Azure se dispara automáticamente, compila y actualiza el entorno productivo.  
  - **Beneficios:** escalado automático, monitorización nativa, configuración de variables de entorno (como cadenas de conexión y claves secretas) directamente en el portal de Azure.  

Este esquema garantiza que el backend esté siempre disponible bajo HTTPS, con tolerancia a fallos y capacidad de crecer según la demanda.

Con estos tres componentes automatizados, AventuraPe dispone de un entorno de producción sólido y escalable, listo para crecer con cada nueva funcionalidad y mantener la continuidad del servicio sin fricciones.


## 5.2. Product Implementation & Deployment
# 5.2.1 Sprint Backlogs

## Sprint 1 – Objetivo
**Objetivo del Sprint:** Publicar una versión mínima viable (MVP) de la landing page de AventuraPe, con navegación completa e información esencial visible para visitantes.

**Criterio de éxito:** Se considera completo cuando un usuario puede visitar la landing, acceder a las secciones "Sobre Nosotros", "Servicios", "FAQ", "Testimonios" y "Contacto", y navegar sin errores desde un navegador web.

### Sprint Backlog – Sprint 1

| User Story | Task ID | Tarea Técnica | Estimación (hrs) | Responsable | Estado |
|------------|---------|---------------|------------------|-------------|--------|
| US01 | TSK-01 | Diseñar estructura base de la landing page en HTML/CSS | 3 | Jimena y Barbara | Done |
| US01 | TSK-02 | Implementar navegación con anclas e íconos interactivos | 2 | Jair | Done |
| US02 | TSK-03 | Diseñar sección de servicios con cards y botones de acción | 4 | Jimena y Barbara | Done |
| US04 | TSK-04 | Codificar sección "Sobre Nosotros" con diseño responsive | 3 | Jair | Done |
| US05 | TSK-05 | Implementar sección de testimonios en carrusel dinámico | 5 | Jimena | Done |
| US06 | TSK-06 | Programar sección de contacto con validación de formulario | 4 | Jimena y Jair| Done |
| US01 | TSK-07 | Configurar GitHub Pages + GitHub Actions para despliegue | 2 | Jimena y Barbara| Done |

## Sprint 2 – Objetivo

**Objetivo del Sprint:** Desarrollar e implementar funcionalidades de gestión de usuarios para aventureros: registro, inicio de sesión y visualización de actividades.

**Criterio de éxito:** El sistema debe permitir que un usuario aventurero se registre, inicie sesión y vea publicaciones desde el frontend, todo probado en entorno local.

### Sprint Backlog – Sprint 2 (Aventurero)

| User Story | Task ID | Tarea Técnica | Estimación (hrs) | Responsable | Estado |
|------------|---------|---------------|------------------|-------------|--------|
| US04 | TSK-08 | Crear formulario de login (frontend) con validaciones | 4 | Stefano | Done (local) |
| US06 | TSK-09 | Backend: endpoint POST `/sign-up` con validaciones | 4 | Stefano | Done (local) |
| US11 | TSK-10 | Visualizar mapa interactivo en app móvil (dummy data) | 6 | Stefano | In Progress |
| US12 | TSK-11 | Implementar búsqueda de actividades (frontend móvil) | 4 | Barbara | Done (local) |
| US13 | TSK-12 | Agregar funcionalidad de filtro por nombre | 4 | Jair | In Progress (local) |
| US17 | TSK-13 | Backend: guardar favoritos en lista personal | 3 | Barbara | In Progress |

## Sprint 3 – Objetivo

**Objetivo del Sprint:** Implementar funcionalidades principales para usuarios empresarios: publicar, editar y eliminar actividades, además de visualizar estadísticas.

**Criterio de éxito:** El empresario puede gestionar sus publicaciones desde el frontend móvil y visualizar sus estadísticas generales, todo en entorno local.

### Sprint Backlog – Sprint 3 (Empresario)

| User Story | Task ID | Tarea Técnica | Estimación (hrs) | Responsable | Estado |
|------------|---------|---------------|------------------|-------------|--------|
| US08 | TSK-14 | Crear formulario de publicación de actividades | 5 | Barbara | Done (local) |
| US09 | TSK-15 | Implementar flujo de edición (form + vista previa) | 4 | Jimena | Done (local) |
| US10 | TSK-16 | Backend: lógica para eliminar publicaciones | 3 | Barbara | Done (local) |
| US19 | TSK-17 | Dashboard estadístico: visitas y comentarios por publicación | 5 | Jose | Done (local) |
| US05 | TSK-18 | Login empresario con validación de credenciales | 3 | Stefano | Done (local) |

## Enlace al tablero Trello del proyecto

**Trello URL público:** [https://trello.com/invite/b/67fec4eb81fae4e3cb20bc4a/ATTIbaa9f91c96fe0bff5f0c939bfdaa9ee46306E3A0/1asi0732-2510-4438-grupo2](#)

### 5.2.2. Implemented Landing Page Evidence
#### *Link del despliegue de la landing:* https://aventurape-androidsoftware.github.io/AventuraPe_LandingPage/


### Evidencia de la Landing Page :
<img src="images/evidence/Evidence_landing_1.jpg"></img><br>

<img src="images/evidence/Evidence_landing_2.jpg"></img><br>

<img src="images/evidence/Evidence_landing_3.jpg"></img><br>

<img src="images/evidence/Evidence_landing_4.jpg"></img><br>

<img src="images/evidence/Evidence_landing_5.jpg"></img><br>

<img src="images/evidence/Evidence_landing_6.jpg"></img><br>

<img src="images/evidence/Evidence_landing_7.jpg"></img><br>

<img src="images/evidence/Evidence_landing_8.jpg"></img><br>


### 5.2.3. Implemented Frontend-Web Application Evidence  

### 5.2.4. Implemented Native-Mobile Application Evidence  

### Login Management
<img src="images/evidence/Evidence_login_management.jpg"></img><br>

### Register Management
<img src="images/evidence/Evidence_register_management.jpg"></img><br>

<img src="images/evidence/Evidence_register_management_2.jpg"></img><br>

### Post Activity  Management
<img src="images/evidence/Evidence_post_activity_management.jpg"></img><br>

<img src="images/evidence/Evidence_post_activity_management_2.jpg"></img><br>

### Account Adventurer 
<img src="images/evidence/Evidence_account_adventurer.jpg"></img><br>

<img src="images/evidence/Evidence_account_adventurer_2.jpg"></img><br>

### Account Entrepreneur 
<img src="images/evidence/Evidence_account_entrepreneur.jpg"></img><br>

<img src="images/evidence/Evidence_account_entrepreneur_2.jpg"></img><br>

### All Publitacions
<img src="images/evidence/Evidence_all_publications.jpg"></img><br>

### Detail Publitacions
<img src="images/evidence/Evidence_detail_publication.jpg"></img><br>

<img src="images/evidence/Evidence_detail_publication_2.jpg"></img><br>


### 5.2.5. Implemented RESTful API and/or Serverless Backend Evidence  

Hemos añadido correctamente nuestros servicios web bajo una arquitectura RESTful, implementando correcciones en todos los endpoints existentes. Además, hemos añadido un nuevo endpoint llamado favorite-publications, que permite a los usuarios gestionar sus publicaciones favoritas de manera más eficiente.
La nueva funcionalidad de favorite-publications permite a los usuarios obtener, añadir y eliminar publicaciones de su lista de favoritos, mejorando la interacción con el contenido que más les interesa. La documentación de todos los endpoints está disponible a través de Swagger, lo que facilita la interacción con la API.

Acción | Endpoint | Detalles | Enlace
------- | -------- | -------- | --------
POST | /authentication/sign-up | Registro de un nuevo usuario | http://localhost:8090/swagger-ui/index.html#/  
 | /authentication/sign-in | Autenticación de usuario (inicio de sesión) |
 | /publication/{publicationId}/add-comment | Añadir comentario a una publicación específica |
 | /publication/create-publication | Crear una nueva publicación |
 | /profiles | Crear un nuevo perfil de usuario |
GET | /publication/{publicationId}/comments | Obtener comentarios de una publicación específica |
 | /publication/{entrepreneurId}/publications | Obtener todas las publicaciones de un emprendedor específico |
 | /publication/all-publications | Obtener todas las publicaciones disponibles |
 | /publication/all-comments | Obtener todos los comentarios |
 | /publication/{publicationId} | Obtener detalles de una publicación específica |
 | /profiles | Obtener todos los perfiles de usuarios |
 | /profiles/name/{name} | Buscar perfiles por nombre |
 | /profiles/location/{location} | Buscar perfiles por ubicación |
 | /profiles/id/{profileId} | Obtener perfil por ID específico |
PUT | /publication/{publicationId}/update-publication | Actualización de una publicación específica |
 | /profiles/{profileId} | Actualizar el perfil de un usuario específico |
DELETE | /publication/{publicationId}/delete-publication | Eliminar una publicación específica |


### 5.2.6. RESTful API documentation  
Utilizamos Swagger para documentar y probar los endpoints de la API de manera interactiva, lo que facilita a los desarrolladores la integración y verificación de los servicios RESTful.

### Api Documentation

<img src="images/evidence/Evidence_api_documentation.jpg"></img><br>

<img src="images/evidence/Evidence_api_documentation (2).jpg"></img><br>

<img src="images/evidence/Evidence_api_documentation (3).jpg"></img><br>


### Login Management
<img src="images/evidence/Evidence_sign_in.jpg"></img><br>

<img src="images/evidence/Evidence_sign_up.jpg"></img><br>

### Publication Management

<img src="images/evidence/Evidence_publication (2).jpg"></img><br>

<img src="images/evidence/Evidence_publication (3).jpg"></img><br>

<img src="images/evidence/Evidence_publication (4).jpg"></img><br>

<img src="images/evidence/Evidence_publication (5).jpg"></img><br>

<img src="images/evidence/Evidence_publication (6).jpg"></img><br>

<img src="images/evidence/Evidence_publication.jpg"></img><br>

### Account Management

<img src="images/evidence/Evidence_profiles_management (2).jpg"></img><br>

<img src="images/evidence/Evidence_profiles_management (3).jpg"></img><br>

<img src="images/evidence/Evidence_profiles_management.jpg"></img><br>

### User Management

<img src="images/evidence/Evidence_user_management (2).jpg"></img><br>

<img src="images/evidence/Evidence_user_management.jpg"></img><br>

### Role Management

<img src="images/evidence/Evidence_role_management.jpg"></img><br>

### 5.2.7. Team Collaboration Insights  
*Durante cada sprint, la colaboración efectiva dentro del equipo es fundamental para garantizar el éxito del proyecto. En el primer sprint, nuestro enfoque principal fue la implementación del backend.*



## 5.3. Video About-the-Product  

# Part II: Verification, Validation & Pipeline  

# Capítulo VI: Product Verification & Validation

## 6.1. Testing Suites & Validation  
### 6.1.1. Core Entities Unit Tests  
### 6.1.2. Core Integration Tests  
### 6.1.3. Core Behavior-Driven Development  
### 6.1.4. Core System Tests  

## 6.2. Static testing & Verification  
### 6.2.1. Static Code Analysis  
#### 6.2.1.1. Coding standard & Code conventions  
#### 6.2.1.2. Code Quality & Code Security  
### 6.2.2. Reviews  

## 6.3. Validation Interviews  
### 6.3.1. Diseño de Entrevistas  
### 6.3.2. Registro de Entrevistas  
### 6.3.3. Evaluaciones según heurísticas  

## 6.4. Auditoría de Experiencias de Usuario  
### 6.4.1. Auditoría realizada  
#### 6.4.1.1. Información del grupo auditado  
#### 6.4.1.2. Cronograma de auditoría realizada  
#### 6.4.1.3. Contenido de auditoría realizada  
### 6.4.2. Auditoría recibida  
#### 6.4.2.1. Información del grupo auditor  
#### 6.4.2.2. Cronograma de auditoría recibida  
#### 6.4.2.3. Contenido de auditoría recibida  
#### 6.4.2.4. Resumen de modificaciones para subsanar hallazgos  

# Capítulo VII: DevOps Practices

## 7.1. Continuous Integration  
### 7.1.1. Tools and Practices  
### 7.1.2. Build & Test Suite Pipeline Components  

## 7.2. Continuous Delivery  
### 7.2.1. Tools and Practices  
### 7.2.2. Stages Deployment Pipeline Components  

## 7.3. Continuous deployment  
### 7.3.1. Tools and Practices  
### 7.3.2. Production Deployment Pipeline Components  

## 7.4. Continuous Monitoring  
### 7.4.1. Tools and Practices  
### 7.4.2. Monitoring Pipeline Components  
### 7.4.3. Alerting Pipeline Components  
### 7.4.4. Notification Pipeline Components  

# Part III: Experiment-Driven Lifecycle  

# Capítulo VIII: Experiment-Driven Development

## 8.1. Experiment Planning  
### 8.1.1. As-Is Summary  
### 8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims  
### 8.1.3. Experiment-Ready Questions  
### 8.1.4. Question Backlog  
### 8.1.5. Experiment Cards  

## 8.2. Experiment Design  
### 8.2.1. Hypotheses  
### 8.2.2. Measures  
### 8.2.3. Conditions  
### 8.2.4. Scale Calculations and Decisions  
### 8.2.5. Methods Selection  
### 8.2.6. Data Analytics: Goals, KPIs and Metrics Selection  
### 8.2.7. Web and Mobile Tracking Plan  

## 8.3. Experimentation  
### 8.3.1. To-Be User Stories  
### 8.3.2. To-Be Product Backlog  
### 8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle  
#### 8.3.3.1. To-Be Sprint Backlogs  
#### 8.3.3.2. Implemented To-Be Landing Page Evidence  
#### 8.3.3.3. Implemented To-Be Frontend-Web Application Evidence  
#### 8.3.3.4. Implemented To-Be Native-Mobile Application Evidence  
#### 8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence  
#### 8.3.3.6. Team Collaboration Insights  

### 8.3.4. To-Be Validation Interviews  
#### 8.3.4.1. Diseño de Entrevistas  
#### 8.3.4.2. Registro de Entrevistas  

## 8.4. Experiment Aftermath & Analysis  
### 8.4.1. Analysis and Interpretation of Results  
### 8.4.2. Re-scored and Re-prioritized Question Backlog  

## 8.5. Continuous Learning  
### 8.5.1. Shareback Session Artifacts: Learning Workflow  

## 8.6. To-Be Software Platform Pre-launch  
### 8.6.1. About-the-Product Intro Video  

# Conclusiones  
## Conclusiones y recomendaciones  

# Video About-the-Team  

# Bibliografía  

# Anexos  

